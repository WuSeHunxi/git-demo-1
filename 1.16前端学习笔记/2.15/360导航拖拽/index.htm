<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            业务问题-->逻辑问题
        如何实现拖拽：需要使用到定位
        1.将所有的li元素变成定位元素
            1.1获取li元素
            1.2获取所有li元素的当前位置
            1.3将所有li改成定位布局
            1.4给每一个li重新设置新的位置值
        2.让每一个元素可以拖拽
            li元素的新位置=li元素的旧位置+li元素移动的距离
            2.1获取鼠标点中li元素时，鼠标的位置
            2.2获取鼠标点中时，元素的旧位置
            2.3获取鼠标滑动的位置
            2.4计算鼠标的新位置
            2.5设置元素的新位置
        */    
        var aLi=document.querySelectorAll("li");
        var len=aLi.length;
        var oNav=document.querySelector(".nav");
        for(var i=0;i<len;i++){
            //通过一个数组把li的横纵坐标都保存起来
            aLiPs.push([aLi[i].offsetTop],aLi[i].offsetLeft);
            setTimeout(function(){
                aLi.style.position="absolute";
                aLi[i].top=aLiPs[i]+"px";
                aLi[i].left=aLiPs[i]+"px";    
            },0);//tms之后执行函数
            /*
            event:事件类型
            type:到底是哪个事件
            */
            oNav.addEventListener("mousedown",drag);
            document.addEventListener("mousemove",drag);
            document.addEventListener("mouseup",drag);
            var toggle=false;//默认没有点中元素
            var x1,y1;//鼠标点击的位置
            var startX,startY;//鼠标点击的旧位置
            var z=1;
            var goalEle=null;//用来判断是否碰撞成功了的元素
            function drag(event){
                //阻止默认事件(元素不让我们移动的事件)
                event.preventDefault();
                //匹配类别
                //当元素被点击了 就能够滑动
                switch(event.type){//事件分流 事件节流
                    case "mousedown":
                        if(event.target.parentNode==="LI"){
                            toggle=true;
                            event.target.parentNode.style.zIndex+=1;
                            x1=event.clientX;
                            y1=event.clientY;
                            startX=event.target.parentNode.offsetLeft;
                            startY=event.target.parentNode.offsetTop;
                        }
                        break;
                    case "mousemove":
                        if(toggle){//事件节流
                            //获取鼠标滑动位置

                            var x2=event.clientX;
                            var y2=event.clientY;
                            //计算元素新位置
                            var nowX=startX+x2-x1;
                            var nowY=startY+y2-y1;
                            //设置元素的新位置
                            event.target.parentNode.style.left=nowX+"px";
                            event.target.parentNode.style.top=nowY+"px";
                            //获取鼠标滑动的相对位置
                            var xr=x2-oNav.offsetLeft;
                            var yr=y2.oNav.offsetTop;
                            for(var n=0;n<len;n++){
                                aLi[n].style.transform="";
                                //不能自己和自己碰撞
                                if(aLi[n]!=event.target.parentNode&&xr>aLi[n].offsetLeft&&xr<aLi[n].offsetLeft+200
                                &&yr>aLi[n].offsetTop&&yr<aLi[n].offsetTop+120){
                                    aLi[n].style.transform="scale(1.05)";
                                    goalEle=aLi[n];
                                }
                            }
                        }
                        break;
                    case "mouseup":
                        if(toggle){//如果点击到了元素
                            toggle=false;
                            //如果碰撞成功的话需要交换
                            if(goalEle){
                                event.target.parentNode.style.left=goalEle.offsetLeft+"px";
                                event.target.parentNode.style.top=goalEle.offsetTop+"px";
                                goalEle.style.left=startX+"px";
                                goalEle.style.top=startY+"px";
                                goalEle=null;
                            }else{//否则的话要变回原来的样式
                                event.target.parentNode.style.left=startX+"px";
                                event.target.parentNode.style.top=startY+"px";
                            }
                        }
                        break;
                }
            }
        }
        /*
        给九个元素绑定一个函数 所占的内存空间太大了

        事件绑定：
            速度快，时间复杂度低，空间复杂度高
        事件监听：
            内存消耗随着元素的增加而减少，空间复杂度低
        事件分流：
            为了可读性，维护性
        目标群体：
            内存更重要
        */
        /*
        碰撞检测：
            1.鼠标位置：主动碰撞
        */
    </script>
</body>
</html>