1.联动效果(利用了回调函数)
    <style>
        *{
            padding: 0;
            margin: 0;
            list-style: none;
        }
        img{
            vertical-align: top;
        }
        #box{
            position: fixed;
            right: 0;
            bottom: 0;
        }
        #close{
            width: 25px;
            height: 25px;
            background-color: red;
            right: 0;
            top: 0;
            position:absolute;
        }
    </style>
    <div id="box">
        <span id="close"></span>
        <div id="top">
            <img src="images/a1.png" alt="">
        </div>
        <div id="bottom">
            <img src="images/a2.png" alt="">
        </div>
    </div>
    <script src="js/my_func.js"></script>
    <script>
        var box=$("box");
        var bottom=$("bottom");
        var close=$("close");
        var top=$("top");
        //监听点击事件(利用回调函数)
        close.onclick=function(){
            buffer(bottom,{height:0},function(){
                buffer(box,{width:0},function(){
                    close.style.display="none";//当图片都消失之后要让close也消失，不然会留在原来的位置
                });
            });
        }
    </script>
2.闭包；在内部返回一个函数,在外部直接调用这个函数
    用处:可以读取函数内部的变量
         让这些变量的值始终保持在内存中
    function test(){
        var age=19;
        return function(){
            console.log(age);
        }
    }
    var fun=test();//得到的就是可以输出年龄的函数
    console.log(fun);
    fun();//输出年龄
        使用场景：
            封闭作用域：又称封闭空间
                其基本结构：(function(){})();
                        ;(function(){})();
                        +(function(){})();
                        -(function(){})();
                        ?(function(){})();
                其最大目的：全局变量私有化
                    (function(){
                        var age=19;
                        console.log(age);
                    })();
                    (function(){
                        console.log(age);//报错，此时变量私有化，不能在该函数中使用
                    })();
            作用域链：
                嵌套之间的函数会形成作用域链，每次对变量的访问实际上是对整条作用域链的遍历查找，
                先找到最近的作用域，一层层往上找，如果在某个作用域找到了，那么本次查找结束
                var num=3;
                (function(){
                    (function(){
                        (function(){
                            (function(){
                                var num=4;
                                console.log(num);//4(外面的num对里面的没有影响)
                            })();
                        })();
                    })();
                })();
                性能优化：
                    (function(){
                        var btn=document.getElementById("btn");//每次都需要查找
                        var btn=document.getElementById("btn");
                        var btn=document.getElementById("btn");
                        var btn=document.getElementById("btn");
                        var btn=document.getElementById("btn");
                    })();
                    (function(){
                        var d=document;
                        var btn=d.getElementById("btn");//需要查找
                        var btn1=d.getElementById("btn");//无需查找
                        var btn2=d.getElementById("btn");
                        var btn3=d.getElementById("btn");
                        var btn4=d.getElementById("btn");
                    })();
                    (function(document){//接收到参数
                        var btn=d.getElementById("btn");//需要查找
                        var btn1=d.getElementById("btn");//无需查找
                        var btn2=d.getElementById("btn");
                        var btn3=d.getElementById("btn");
                        var btn4=d.getElementById("btn");
                    })(document);//传参
            高级排他：(只需要把之前的都清除，只选中当前的即可，不用遍历所有的在清除)
            参数传递：
                <style>
                    .box{
                        margin: 100px auto;
                        height: 400px;
                        width: 200px;
                    }
                </style>
                <div class="box">
                    <img id="r" src="images/a1.png" alt=""></br>
                    <img id="l" src="images/a2.png" alt="">
                </div>
                <script>
                    // function test(x){
                    //     return function(y){
                    //         console.log(x);
                    //         console.log(y);
                    //     }
                    // }
                    // test(10)(9);    
                    function move(speed){//特殊情况(事件处理的内容差不多相同的时候可以利用闭包)
                        var num=0;
                        return function(){
                            num=speed+num;
                            this.style.marginLeft=num+"px";
                        }
                    }
                    var rImg=document.getElementById("r");
                    var lImg=document.getElementById("l");
                    rImg.onmousedown=move(-50);
                    lImg.onmousedown=move(50);
                </script>
            函数节流：
                //节流的函数：onresize+onscroll
                function throttle(fn,delay){
                    var time=null;
                    clearInterval(time);
                    time=setInterval(fn,delay);
                } 
3.楼梯效果(点击哪层进入哪层)